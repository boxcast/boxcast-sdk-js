{"version":3,"file":"node.js","sources":["webpack://boxcast-sdk-js/webpack/universalModuleDefinition","webpack://boxcast-sdk-js/./src/analytics/chromecast.ts","webpack://boxcast-sdk-js/./src/analytics/html5.ts","webpack://boxcast-sdk-js/./src/analytics/index.ts","webpack://boxcast-sdk-js/./src/analytics/react-native-video.ts","webpack://boxcast-sdk-js/./src/analytics/videojs.ts","webpack://boxcast-sdk-js/./src/api/auth_broadcast_routes.ts","webpack://boxcast-sdk-js/./src/api/auth_channel_routes.ts","webpack://boxcast-sdk-js/./src/api/auth_routes.ts","webpack://boxcast-sdk-js/./src/api/base_routes.ts","webpack://boxcast-sdk-js/./src/api/broadcast_routes.ts","webpack://boxcast-sdk-js/./src/api/channel_routes.ts","webpack://boxcast-sdk-js/./src/api/index.ts","webpack://boxcast-sdk-js/./src/api/view_routes.ts","webpack://boxcast-sdk-js/./src/config.ts","webpack://boxcast-sdk-js/./src/main.ts","webpack://boxcast-sdk-js/./src/node.ts","webpack://boxcast-sdk-js/./src/state.ts","webpack://boxcast-sdk-js/./src/utils/clock.ts","webpack://boxcast-sdk-js/./src/utils/index.ts","webpack://boxcast-sdk-js/./src/utils/monotonic_clock.ts","webpack://boxcast-sdk-js/external \"base-64\"","webpack://boxcast-sdk-js/external \"node-fetch\"","webpack://boxcast-sdk-js/external \"platform\"","webpack://boxcast-sdk-js/external \"qs\"","webpack://boxcast-sdk-js/webpack/bootstrap","webpack://boxcast-sdk-js/webpack/runtime/compat get default export","webpack://boxcast-sdk-js/webpack/runtime/define property getters","webpack://boxcast-sdk-js/webpack/runtime/hasOwnProperty shorthand","webpack://boxcast-sdk-js/webpack/runtime/make namespace object","webpack://boxcast-sdk-js/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function() {\nreturn ","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nimport Html5VideoAnalytics from './html5';\nconst DVR_WINDOW_S = 30;\nexport default class ChromecastAnalytics extends Html5VideoAnalytics {\n    get framework() {\n        const cast = typeof window !== 'undefined' ? window.cast : global.cast;\n        return cast.framework;\n    }\n    attach(params) {\n        const { playerManager, broadcastInfo } = params;\n        if (!playerManager)\n            throw Error('playerManager is required');\n        if (!broadcastInfo)\n            throw Error('broadcastInfo is required');\n        this.playerManager = playerManager;\n        this.broadcastInfo = broadcastInfo;\n        this.lastReportAt = null;\n        this.lastBufferStart = null;\n        this.isPlaying = false;\n        this.isBuffering = false;\n        this.durationPlaying = 0;\n        this.activeBufferingDuration = 0;\n        this.totalDurationBuffering = 0;\n        this.currentLevelHeight = 0;\n        this.headers = {};\n        this.isSetup = false;\n        this._wireEvents();\n        return this;\n    }\n    handleSegmentRequest(requestInfo) {\n        // Set the current level height to whatever level we're most recently requesting.\n        if (!requestInfo.url)\n            return;\n        const m = requestInfo.url.match(/\\/(\\d+)p\\/\\d+\\.ts/);\n        if (!m || !m[1])\n            return;\n        this.currentLevelHeight = parseInt(m[1], 10);\n    }\n    _wireEvents() {\n        this.playerManager.addEventListener(this.framework.events.EventType.ENDED, (event) => {\n            this._handleNormalOperation();\n            this._report('complete');\n            this._handleBufferingEnd();\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.MEDIA_FINISHED, (event) => {\n            this._handleNormalOperation();\n            this._report('complete');\n            this._handleBufferingEnd();\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.ERROR, (event) => {\n            this._handleChromecastError(event);\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.PAUSE, (event) => {\n            this._handleNormalOperation();\n            this._report('pause');\n            this._handleBufferingEnd();\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.PLAYING, (event) => {\n            this._handleNormalOperation();\n            this._report('play');\n            this.isPlaying = true;\n            this._handleBufferingEnd();\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.REQUEST_STOP, (event) => {\n            this._handleNormalOperation();\n            this._report('stop');\n            this._handleBufferingEnd();\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.SEEKED, (event) => {\n            this._handleNormalOperation();\n            this._handleBufferingEnd();\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.SEEKING, (event) => {\n            if (event && event.currentMediaTime) {\n                this._handleNormalOperation();\n                this._report('seek', { offset: event.currentMediaTime });\n            }\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.TIME_UPDATE, (event) => {\n            if (event.currentMediaTime && this.lastTimeUpdateTime && (event.currentMediaTime !== this.lastTimeUpdateTime)) {\n                this._handleNormalOperation();\n                this._handleBufferingEnd();\n            }\n            this.lastTimeUpdateTime = event.currentMediaTime;\n            this._reportTime();\n        });\n        this.playerManager.addEventListener(this.framework.events.EventType.BUFFERING, (event) => {\n            if (event.isBuffering) {\n                this._handleBufferingStart();\n            }\n            else {\n                this._handleNormalOperation();\n                this._handleBufferingEnd();\n            }\n        });\n    }\n    _handleChromecastError(event) {\n        if (this.stoppedHACK) {\n            console.warn('An error occurred, but playback is stopped so this should not be a problem', event);\n        }\n        else if (event === null) {\n            console.warn('An error event was fired, but the error was null');\n        }\n        else {\n            let errorObject = {};\n            if (event.detailedErrorCode) {\n                errorObject.code = event.detailedErrorCode;\n                switch (event.detailedErrorCode) {\n                    case this.framework.events.DetailedErrorCode.MEDIA_UNKNOWN:\n                        errorObject.message = 'MEDIA_UNKNOWN';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIA_ABORTED:\n                        errorObject.message = 'MEDIA_ABORTED';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIA_DECODE:\n                        errorObject.message = 'MEDIA_DECODE';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIA_NETWORK:\n                        errorObject.message = 'MEDIA_NETWORK';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIA_SRC_NOT_SUPPORTED:\n                        errorObject.message = 'MEDIA_SRC_NOT_SUPPORTED';\n                        break;\n                    case this.framework.events.DetailedErrorCode.SOURCE_BUFFER_FAILURE:\n                        errorObject.message = 'SOURCE_BUFFER_FAILURE';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIAKEYS_UNKNOWN:\n                        errorObject.message = 'MEDIAKEYS_UNKNOWN';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIAKEYS_NETWORK:\n                        errorObject.message = 'MEDIAKEYS_NETWORK';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIAKEYS_UNSUPPORTED:\n                        errorObject.message = 'MEDIAKEYS_UNSUPPORTED';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIAKEYS_WEBCRYPTO:\n                        errorObject.message = 'MEDIAKEYS_WEBCRYPTO';\n                        break;\n                    case this.framework.events.DetailedErrorCode.NETWORK_UNKNOWN:\n                        errorObject.message = 'NETWORK_UNKNOWN';\n                        break;\n                    case this.framework.events.DetailedErrorCode.SEGMENT_NETWORK:\n                        errorObject.message = 'SEGMENT_NETWORK';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_NETWORK_MASTER_PLAYLIST:\n                        errorObject.message = 'HLS_NETWORK_MASTER_PLAYLIST';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_NETWORK_PLAYLIST:\n                        errorObject.message = 'HLS_NETWORK_PLAYLIST';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_NETWORK_NO_KEY_RESPONSE:\n                        errorObject.message = 'HLS_NETWORK_NO_KEY_RESPONSE';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_NETWORK_KEY_LOAD:\n                        errorObject.message = 'HLS_NETWORK_KEY_LOAD';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_NETWORK_INVALID_SEGMENT:\n                        errorObject.message = 'HLS_NETWORK_INVALID_SEGMENT';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_SEGMENT_PARSING:\n                        errorObject.message = 'HLS_SEGMENT_PARSING';\n                        break;\n                    case this.framework.events.DetailedErrorCode.DASH_NETWORK:\n                        errorObject.message = 'DASH_NETWORK';\n                        break;\n                    case this.framework.events.DetailedErrorCode.DASH_NO_INIT:\n                        errorObject.message = 'DASH_NO_INIT';\n                        break;\n                    case this.framework.events.DetailedErrorCode.SMOOTH_NETWORK:\n                        errorObject.message = 'SMOOTH_NETWORK';\n                        break;\n                    case this.framework.events.DetailedErrorCode.SMOOTH_NO_MEDIA_DATA:\n                        errorObject.message = 'SMOOTH_NO_MEDIA_DATA';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MANIFEST_UNKNOWN:\n                        errorObject.message = 'MANIFEST_UNKNOWN';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_MANIFEST_MASTER:\n                        errorObject.message = 'HLS_MANIFEST_MASTER';\n                        break;\n                    case this.framework.events.DetailedErrorCode.HLS_MANIFEST_PLAYLIST:\n                        errorObject.message = 'HLS_MANIFEST_PLAYLIST';\n                        break;\n                    case this.framework.events.DetailedErrorCode.DASH_MANIFEST_UNKNOWN:\n                        errorObject.message = 'DASH_MANIFEST_UNKNOWN';\n                        break;\n                    case this.framework.events.DetailedErrorCode.DASH_MANIFEST_NO_PERIODS:\n                        errorObject.message = 'DASH_MANIFEST_NO_PERIODS';\n                        break;\n                    case this.framework.events.DetailedErrorCode.DASH_MANIFEST_NO_MIMETYPE:\n                        errorObject.message = 'DASH_MANIFEST_NO_MIMETYPE';\n                        break;\n                    case this.framework.events.DetailedErrorCode.DASH_INVALID_SEGMENT_INFO:\n                        errorObject.message = 'DASH_INVALID_SEGMENT_INFO';\n                        break;\n                    case this.framework.events.DetailedErrorCode.SMOOTH_MANIFEST:\n                        errorObject.message = 'SMOOTH_MANIFEST';\n                        break;\n                    case this.framework.events.DetailedErrorCode.SEGMENT_UNKNOWN:\n                        errorObject.message = 'SEGMENT_UNKNOWN';\n                        break;\n                    case this.framework.events.DetailedErrorCode.TEXT_UNKNOWN:\n                        errorObject.message = 'TEXT_UNKNOWN';\n                        break;\n                    case this.framework.events.DetailedErrorCode.APP:\n                        errorObject.message = 'APP';\n                        break;\n                    case this.framework.events.DetailedErrorCode.BREAK_CLIP_LOADING_ERROR:\n                        errorObject.message = 'BREAK_CLIP_LOADING_ERROR';\n                        break;\n                    case this.framework.events.DetailedErrorCode.BREAK_SEEK_INTERCEPTOR_ERROR:\n                        errorObject.message = 'BREAK_SEEK_INTERCEPTOR_ERROR';\n                        break;\n                    case this.framework.events.DetailedErrorCode.IMAGE_ERROR:\n                        errorObject.message = 'IMAGE_ERROR';\n                        break;\n                    case this.framework.events.DetailedErrorCode.LOAD_INTERRUPTED:\n                        errorObject.message = 'LOAD_INTERRUPTED';\n                        break;\n                    case this.framework.events.DetailedErrorCode.LOAD_FAILED:\n                        errorObject.message = 'LOAD_FAILED';\n                        break;\n                    case this.framework.events.DetailedErrorCode.MEDIA_ERROR_MESSAGE:\n                        errorObject.message = 'MEDIA_ERROR_MESSAGE';\n                        break;\n                    case this.framework.events.DetailedErrorCode.GENERIC:\n                        errorObject.message = 'GENERIC';\n                        break;\n                }\n            }\n            if (event.error) {\n                try {\n                    errorObject.data = JSON.stringify(event.error);\n                }\n                catch (e) { }\n            }\n            this._report('error', Object.assign({}, this.browserState, { error_object: errorObject }));\n        }\n    }\n    _getCurrentTime() {\n        return this.playerManager.getCurrentTimeSec();\n    }\n    _getCurrentLevelHeight() {\n        return this.currentLevelHeight;\n    }\n    _getDvrIsUse() {\n        const liveSeekableRange = this.playerManager.getLiveSeekableRange();\n        if (liveSeekableRange && liveSeekableRange.end) {\n            if (liveSeekableRange.end - this.playerManager.getCurrentTimeSec() < DVR_WINDOW_S) {\n                // Within DVR_WINDOW_S seconds of live head, so not DVR\n                return false;\n            }\n            // More than DVR_WINDOW_S seconds behind, so DVR\n            return true;\n        }\n        // Not live, so not DVR\n        return false;\n    }\n}\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint camelcase: 0 */\n// @ts-nocheck\nimport { uuid, normalizeError, getStorage, cleanQuotesFromViewerID, Clock, MonotonicClock } from '../utils';\nconst METRICS_URL = 'https://metrics.boxcast.com/player/interaction';\nconst PLAYING_STATES = 'play'.split(' ');\nconst STOPPED_STATES = 'pause buffer idle stop complete error'.split(' ');\nconst TIME_REPORT_INTERVAL_MS = 60000;\nconst storage = getStorage();\nexport default class Html5VideoAnalytics {\n    constructor(state) {\n        this.browserState = state;\n        this._queue = [];\n        this.listeners = {};\n    }\n    attach(params) {\n        const { video, broadcast, channel_id } = params;\n        if (!video)\n            throw Error('video is required');\n        if (!broadcast)\n            throw Error('broadcast is required');\n        // Check if we're already attached and reset if so\n        if (Object.keys(this.listeners).length > 0) {\n            this.detach();\n        }\n        this.player = video;\n        this.broadcastInfo = {\n            channel_id: channel_id || broadcast.channel_id,\n            account_id: broadcast.account_id,\n            is_live: (broadcast.timeframe === 'current'),\n            broadcast_id: broadcast.id\n        };\n        this.lastReportAt = null;\n        this.lastBufferStart = null;\n        this.isPlaying = false;\n        this.isBuffering = false;\n        this.durationPlaying = 0;\n        this.activeBufferingDuration = 0;\n        this.totalDurationBuffering = 0;\n        this.currentLevelHeight = 0;\n        this.headers = {};\n        this.isSetup = false;\n        this.listeners = this._wireEvents(this.player);\n        return this;\n    }\n    detach() {\n        // Remove video event listeners\n        Object.keys(this.listeners).forEach((evtName) => {\n            this.player.removeEventListener(evtName, this.listeners[evtName], true);\n        });\n        this.listeners = {};\n        // Clear up other state\n        clearTimeout(this._waitForBufferingCheck);\n        return this;\n    }\n    _wireEvents(v) {\n        const listeners = {\n            'ended': () => {\n                this._handleNormalOperation();\n                this._report('complete');\n                this._handleBufferingEnd();\n            },\n            'error': () => {\n                this._handlePlaybackError(this.player.error);\n            },\n            'pause': () => {\n                this._handleNormalOperation();\n                this._report('pause');\n                this._handleBufferingEnd();\n            },\n            'play': () => {\n                this._handleNormalOperation();\n                this._report('play');\n                this._handleBufferingEnd();\n            },\n            'playing': () => {\n                this._handleNormalOperation();\n                this.isPlaying = true;\n                this._handleBufferingEnd();\n            },\n            'resize': () => {\n                this._handleNormalOperation();\n                this._report('quality');\n                this._handleBufferingEnd();\n            },\n            'seeking': () => {\n                this._handleNormalOperation();\n                this._report('seek', { offset: this.player.currentTime });\n            },\n            'seeked': () => {\n                this._handleNormalOperation();\n                this._handleBufferingEnd();\n            },\n            'timeupdate': () => {\n                this._reportTime();\n            },\n            'stalled': () => {\n                this._handleBufferingStart();\n            },\n            'waiting': () => {\n                this._handleBufferingStart();\n            }\n        };\n        Object.keys(listeners).forEach((evtName) => {\n            v.addEventListener(evtName, listeners[evtName], true);\n        });\n        return listeners;\n    }\n    _isActuallyPlaying() {\n        return !!(this.player.currentTime > 0 && !this.player.paused && !this.player.ended && this.player.readyState > 2);\n    }\n    _getCurrentTime() {\n        return this.player.currentTime;\n    }\n    _getCurrentLevelHeight() {\n        // TODO: consider a more appropriate way to get level height, e.g. if using hls.js\n        return this.player.videoHeight;\n    }\n    _handleBufferingStart() {\n        this.isBuffering = true;\n        this.lastBufferStart = this.lastBufferStart || MonotonicClock.now();\n        // Make sure it *stays* buffering for at least 500ms before reporting\n        if (this._waitForBufferingCheck) {\n            return;\n        }\n        this._waitForBufferingCheck = setTimeout(() => {\n            this._waitForBufferingCheck = null;\n            if (!this.isBuffering) {\n                return;\n            }\n            if (this._isActuallyPlaying()) {\n                this._handleBufferingEnd();\n                return;\n            }\n            this._report('buffer');\n        }, 500);\n    }\n    _handleNormalOperation() {\n        this.stoppedHACK = false;\n    }\n    _handleBufferingEnd() {\n        this.isBuffering = false;\n        this.lastBufferStart = null;\n        clearTimeout(this._waitForBufferingCheck);\n        this._waitForBufferingCheck = null;\n        // When done buffering, accumulate the time since it started buffering and\n        // reset the active buffering timer.\n        this.totalDurationBuffering += this.activeBufferingDuration;\n        this.activeBufferingDuration = 0;\n    }\n    _handlePlaybackError(error) {\n        if (this.stoppedHACK) {\n            console.warn('An error occurred, but playback is stopped so this should not be a problem', error);\n        }\n        else if (error === null) {\n            console.warn('An error event was fired, but the error was null'); // Ugh, Firefox\n        }\n        else {\n            this._report('error', Object.assign({}, this.browserState, { error_object: normalizeError(error) }));\n        }\n    }\n    _setup() {\n        var viewerId = storage.getItem('boxcast-viewer-id', null);\n        if (!viewerId) {\n            viewerId = cleanQuotesFromViewerID(uuid().replace(/-/g, ''));\n            storage.setItem('boxcast-viewer-id', viewerId);\n        }\n        this.headers = Object.assign({\n            view_id: uuid().replace(/-/g, ''),\n            viewer_id: viewerId\n        }, this.broadcastInfo);\n    }\n    _reportTime() {\n        if (!this.isSetup || !this.isPlaying) {\n            return;\n        }\n        var n = MonotonicClock.now();\n        if ((n - this.lastReportAt) <= TIME_REPORT_INTERVAL_MS) {\n            return;\n        }\n        this._report('time');\n    }\n    _report(action, options) {\n        if (!this.isSetup) {\n            this._setup();\n            this.isSetup = true; // avoid infinite loop\n            this._report('setup', this.browserState);\n        }\n        var n = MonotonicClock.now();\n        if (this.isPlaying) {\n            // Accumulate the playing counter stat between report intervals\n            this.durationPlaying += (n - (this.lastReportAt || n));\n        }\n        if (this.isBuffering) {\n            // The active buffering stat is absolute (*not* accumulated between report intervals)\n            this.activeBufferingDuration = (n - (this.lastBufferStart || n));\n        }\n        this.isPlaying = PLAYING_STATES.indexOf(action) >= 0 || (this.isPlaying && !(STOPPED_STATES.indexOf(action) >= 0));\n        this.lastReportAt = n;\n        let c = Clock.now();\n        options = options || {};\n        options = Object.assign({}, this.headers, options);\n        options.timestamp = c.toISOString();\n        options.hour_of_day = c.getHours(); // hour-of-day in local time\n        options.day_of_week = c.getDay();\n        options.action = action;\n        options.position = this._getCurrentTime();\n        options.duration = Math.round(this.durationPlaying / 1000);\n        options.duration_buffering = Math.round((this.totalDurationBuffering + this.activeBufferingDuration) / 1000);\n        options.videoHeight = this._getCurrentLevelHeight();\n        if (this._getDvrIsUse) {\n            options.dvr = this._getDvrIsUse();\n        }\n        this._queue.push(options);\n        this._dequeue();\n    }\n    _dequeue() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var requeue = [];\n            for (const options of this._queue) {\n                try {\n                    const response = yield fetch(METRICS_URL, {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: JSON.stringify(options)\n                    });\n                    if (!response.ok) {\n                        throw new Error(`Failed to post metrics with status ${response.status}`);\n                    }\n                }\n                catch (error) {\n                    options.__attempts = (options.__attempts || 0) + 1;\n                    if (options.__attempts <= 5) {\n                        console.warn('Unable to post metrics; will retry', normalizeError(error), options);\n                        requeue.push(options);\n                    }\n                    else {\n                        console.warn('Unable to post metrics; will not retry', normalizeError(error), options);\n                    }\n                }\n            }\n            // Add any messages that failed to try to resend on next batch\n            this._queue = requeue;\n        });\n    }\n}\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\n/* global NPM_VERSION */\n/* eslint camelcase: 0 */\n// @ts-nocheck\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar _fetch;\nimport platform from 'platform';\nimport Html5VideoAnalytics from './html5';\nimport VideoJsAnalytics from './videojs';\nimport ChromecastAnalytics from './chromecast';\nimport ReactNativeVideoAnalytics from './react-native-video';\nvar OVERRIDE_STATE = {};\nfunction guessHost() {\n    try {\n        return window.location.hostname;\n    }\n    catch (e) {\n        return '';\n    }\n}\nfunction guessOS() {\n    return (platform.os || '').toString();\n}\nexport class analytics {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        this.configure = (params) => {\n            OVERRIDE_STATE = params;\n            return this;\n        };\n        this.getState = () => {\n            var browserState = {\n                host: guessHost(),\n                os: guessOS(),\n                browser_name: platform.name,\n                browser_version: platform.version,\n                player_version: `boxcast-sdk-js v${process.env.NPM_VERSION}`\n            };\n            return Object.assign({}, browserState, OVERRIDE_STATE);\n        };\n        this.mode = (mode) => {\n            switch (mode) {\n                case 'html5':\n                    return new Html5VideoAnalytics(this.getState());\n                case 'video.js':\n                    return new VideoJsAnalytics(this.getState());\n                case 'chromecast':\n                    return new ChromecastAnalytics(this.getState());\n                case 'react-native-video':\n                    return new ReactNativeVideoAnalytics(this.getState());\n            }\n            throw Error(`Mode ${mode} not supported`);\n        };\n        __classPrivateFieldSet(this, _fetch, fetch);\n    }\n}\n_fetch = new WeakMap();\nexport default analytics;\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint camelcase: 0 */\n// @ts-nocheck\nimport { uuid, normalizeError, Clock, MonotonicClock } from '../utils';\nconst METRICS_URL = 'https://metrics.boxcast.com/player/interaction';\nconst PLAYING_STATES = 'play'.split(' ');\nconst STOPPED_STATES = 'pause buffer complete error'.split(' ');\nconst DOUBLE_REPORT_DEBOUNCE_MIN_MS = 1000;\nconst TIME_REPORT_INTERVAL_MS = 60000;\nconst BUFFERING_MIN_TIME_TO_REPORT_MS = 1000;\nexport default class ReactNativeVideoAnalytics {\n    constructor(state) {\n        this.browserState = state;\n        this._queue = [];\n    }\n    attach(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { broadcast, channel_id, AsyncStorage, debug } = params;\n            if (!broadcast)\n                throw Error('broadcast is required');\n            if (!AsyncStorage)\n                throw Error('AsyncStorage is required');\n            this.storage = AsyncStorage;\n            this.debug = debug;\n            this.broadcastInfo = {\n                channel_id: channel_id || broadcast.channel_id,\n                account_id: broadcast.account_id,\n                is_live: (broadcast.timeframe === 'current'),\n                broadcast_id: broadcast.id\n            };\n            this.lastAction = null;\n            this.lastReportAt = null;\n            this.lastBufferStart = null;\n            this.isPlaying = false;\n            this.isBuffering = false;\n            this.durationPlaying = 0;\n            this.activeBufferingDuration = 0;\n            this.totalDurationBuffering = 0;\n            this.currentLevelHeight = 0;\n            this.headers = {};\n            this.isSetup = false;\n            this._bufferTimeoutHandle = null;\n            yield this._initViewerID();\n            return this;\n        });\n    }\n    generateVideoEventProps() {\n        return {\n            onBuffer: this._onBuffer.bind(this),\n            onError: this._onError.bind(this),\n            onLoad: this._onLoad.bind(this),\n            onProgress: this._onProgress.bind(this),\n            onEnd: this._onEnd.bind(this),\n            onPlaybackRateChange: this._onPlaybackRateChange.bind(this)\n        };\n    }\n    _onBuffer(evt) {\n        if (evt.isBuffering) {\n            this._handleBufferingStart();\n        }\n        else {\n            this._handleBufferingEnd();\n        }\n    }\n    _onError(evt) {\n        console.warn('onError:', evt);\n        this._handlePlaybackError(evt);\n    }\n    _onLoad(evt) {\n        this.debug && console.log('onLoad:', evt);\n    }\n    _onProgress(evt) {\n        this._lastProgressTimestamp = evt.currentTime;\n        this._reportTime();\n    }\n    _onEnd(evt) {\n        this._report('complete');\n        this._handleBufferingEnd();\n    }\n    _onPlaybackRateChange(evt) {\n        // XXX: This is the primary trigger for knowing play/buffer/stall.  It goes\n        // from 0<->1 depending on what is happening. The other events do not appear\n        // to be reliable as of react-native-video v4.3.1\n        if (evt.playbackRate === 0) {\n            // rate == 0 --> pause\n            this._report('pause');\n            this._handleBufferingEnd();\n        }\n        else if (evt.playbackRate === 1) {\n            // rate == 1 --> play\n            this._report('play');\n            this._handleBufferingEnd();\n        }\n    }\n    _getCurrentTime() {\n        return this._lastProgressTimestamp;\n    }\n    _handleBufferingStart() {\n        this.isBuffering = true;\n        this.lastBufferStart = this.lastBufferStart || MonotonicClock.now();\n        if (this._bufferTimeoutHandle == null) {\n            this.debug && console.log('[analytics] Detected start of buffering');\n            this._bufferTimeoutHandle = setTimeout(() => {\n                this.isBuffering && this._report('buffer');\n            }, BUFFERING_MIN_TIME_TO_REPORT_MS);\n        }\n    }\n    _handleBufferingEnd() {\n        this.isBuffering = false;\n        this.lastBufferStart = null;\n        // When done buffering, accumulate the time since it started buffering and\n        // reset the active buffering timer.\n        this.totalDurationBuffering += this.activeBufferingDuration;\n        this.activeBufferingDuration = 0;\n        clearTimeout(this._bufferTimeoutHandle);\n        this._bufferTimeoutHandle = null;\n        this.debug && console.log('[analytics] Detected end of buffering');\n    }\n    _handlePlaybackError(error) {\n        if (error === null) {\n            console.warn('An error event was fired, but the error was null'); // Ugh, Firefox\n        }\n        else {\n            this._report('error', Object.assign({}, this.browserState, { error_object: normalizeError(error) }));\n        }\n    }\n    _initViewerID() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var viewerId = yield this.storage.getItem('boxcast-viewer-id');\n            if (!viewerId) {\n                viewerId = uuid().replace(/-/g, '');\n                this.storage.setItem('boxcast-viewer-id', viewerId);\n            }\n            this.headers = Object.assign({\n                view_id: uuid().replace(/-/g, ''),\n                viewer_id: viewerId\n            }, this.broadcastInfo);\n        });\n    }\n    _reportTime() {\n        if (!this.isSetup || !this.isPlaying) {\n            return;\n        }\n        var n = MonotonicClock.now();\n        if ((n - this.lastReportAt) <= TIME_REPORT_INTERVAL_MS) {\n            return;\n        }\n        this._report('time');\n    }\n    _report(action, options) {\n        if (!this.isSetup) {\n            this.isSetup = true; // avoid infinite loop\n            this._report('setup', this.browserState);\n        }\n        // Accumulate the playing/buffering counters\n        var n = MonotonicClock.now();\n        if (this.isPlaying) {\n            // Accumulate the playing counter stat between report intervals\n            this.durationPlaying += (n - (this.lastReportAt || n));\n        }\n        if (this.isBuffering) {\n            // The active buffering stat is absolute (*not* accumulated between report intervals)\n            this.activeBufferingDuration = (n - (this.lastBufferStart || n));\n        }\n        this.isPlaying = PLAYING_STATES.indexOf(action) >= 0 || (this.isPlaying && !(STOPPED_STATES.indexOf(action) >= 0));\n        // Debounce if triggering same report again (often happens with multiple \"play\"s during buffering)\n        if (action === this.lastAction && (n - (this.lastReportAt || n)) < DOUBLE_REPORT_DEBOUNCE_MIN_MS) {\n            this.debug && console.log(`[analytics] Ignoring ${action} due to debounce on last report`);\n            return;\n        }\n        this.lastReportAt = n;\n        this.lastAction = action;\n        let c = Clock.now();\n        options = options || {};\n        options = Object.assign({}, this.headers, options);\n        options.timestamp = c.toISOString();\n        options.hour_of_day = c.getHours(); // hour-of-day in local time\n        options.day_of_week = c.getDay();\n        options.action = action;\n        options.position = this._getCurrentTime();\n        options.duration = Math.round(this.durationPlaying / 1000);\n        options.duration_buffering = Math.round((this.totalDurationBuffering + this.activeBufferingDuration) / 1000);\n        // options.videoHeight = // XXX: TODO: figure out how to determine video height\n        this._queue.push(options);\n        this._dequeue();\n    }\n    _dequeue() {\n        var requeue = [];\n        this._queue.forEach((options) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield fetch(METRICS_URL, {\n                    method: 'POST',\n                    body: JSON.stringify(options),\n                    headers: {\n                        'Content-Type': 'application/json'\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(`Response status ${response.status}`);\n                }\n                this.debug && console.log('[analytics] Posted: ', options);\n            }\n            catch (error) {\n                options.__attempts = (options.__attempts || 0) + 1;\n                if (options.__attempts <= 5) {\n                    console.warn('Unable to post metrics; will retry', normalizeError(error), options);\n                    requeue.push(options);\n                }\n                else {\n                    console.warn('Unable to post metrics; will not retry', normalizeError(error), options);\n                }\n            }\n        }));\n        // Add any messages that failed to try to resend on next batch\n        this._queue = requeue;\n    }\n}\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\n/* eslint camelcase: 0 */\n// @ts-nocheck\nimport Html5VideoAnalytics from './html5';\nexport default class VideoJsAnalytics extends Html5VideoAnalytics {\n    attach(params) {\n        const { player, broadcast, channel_id } = params;\n        if (!player)\n            throw Error('player is required');\n        if (!broadcast)\n            throw Error('broadcast is required');\n        this.player = player;\n        this.broadcastInfo = {\n            channel_id: channel_id || broadcast.channel_id,\n            account_id: broadcast.account_id,\n            is_live: (broadcast.timeframe === 'current'),\n            broadcast_id: broadcast.id\n        };\n        this.lastReportAt = null;\n        this.lastBufferStart = null;\n        this.isPlaying = false;\n        this.isBuffering = false;\n        this.durationPlaying = 0;\n        this.activeBufferingDuration = 0;\n        this.totalDurationBuffering = 0;\n        this.currentLevelHeight = 0;\n        this.headers = {};\n        this.isSetup = false;\n        this.listeners = this._wireEvents(this.player);\n        return this;\n    }\n    detach() {\n        // Remove video event listeners\n        Object.keys(this.listeners).forEach((evtName) => {\n            this.player.off(evtName, this.listeners[evtName]);\n        });\n        this.listeners = {};\n        // Clear up other state\n        clearTimeout(this._waitForBufferingCheck);\n        return this;\n    }\n    _wireEvents(v) {\n        const listeners = {\n            'ended': () => {\n                this._handleNormalOperation();\n                this._report('complete');\n                this._handleBufferingEnd();\n            },\n            'error': (err) => {\n                this._handlePlaybackError(err);\n            },\n            'pause': () => {\n                this._handleNormalOperation();\n                this._report('pause');\n                this._handleBufferingEnd();\n            },\n            'play': () => {\n                this._handleNormalOperation();\n                this._report('play');\n                this._handleBufferingEnd();\n            },\n            'playing': () => {\n                this._handleNormalOperation();\n                this.isPlaying = true;\n                this._handleBufferingEnd();\n            },\n            'resize': () => {\n                this._handleNormalOperation();\n                this._report('quality');\n                this._handleBufferingEnd();\n            },\n            'seeking': () => {\n                this._handleNormalOperation();\n                this._report('seek', { offset: this._getCurrentTime() });\n            },\n            'seeked': () => {\n                this._handleNormalOperation();\n                this._handleBufferingEnd();\n            },\n            'timeupdate': () => {\n                this._reportTime();\n            },\n            'stalled': () => {\n                this._handleBufferingStart();\n            },\n            'waiting': () => {\n                this._handleBufferingStart();\n            }\n        };\n        Object.keys(listeners).forEach((evtName) => {\n            v.on(evtName, listeners[evtName]);\n        });\n        return listeners;\n    }\n    _getCurrentTime() {\n        return this.player.currentTime();\n    }\n    _getCurrentLevelHeight() {\n        return this.player.videoHeight();\n    }\n}\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar _fetch;\nimport { BaseAuthenticatedRoute } from './base_routes';\nexport default class AuthBroadcastRoutes extends BaseAuthenticatedRoute {\n    constructor(fetch) {\n        super(fetch); // call the constructor of the base class\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(// call the constructor of the base class\n        this, _fetch, fetch);\n    }\n    get resourceBase() { return 'broadcasts'; }\n}\n_fetch = new WeakMap();\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar _fetch;\nimport { BaseAuthenticatedRoute } from './base_routes';\nexport default class AuthChannelRoutes extends BaseAuthenticatedRoute {\n    constructor(fetch) {\n        super(fetch); // call the constructor of the base class\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(// call the constructor of the base class\n        this, _fetch, fetch);\n    }\n    get resourceBase() { return 'account/channels'; }\n}\n_fetch = new WeakMap();\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _fetch;\nimport base64 from \"base-64\";\nimport { API_ROOT, AUTH_ROOT } from \"../config\";\nimport { STATE } from \"../state\";\nimport { authHeaders } from \"../utils\";\nimport AuthBroadcastRoutes from \"./auth_broadcast_routes\";\nimport AuthChannelRoutes from \"./auth_channel_routes\";\nexport default class AuthenticatedRoutes {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(this, _fetch, fetch);\n    }\n    logout() {\n        STATE.lastAuthToken = null;\n    }\n    authenticate(clientId, clientSecret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const body = new URLSearchParams({\n                    'grant_type': 'client_credentials',\n                    'scope': 'owner'\n                });\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${AUTH_ROOT}/oauth2/token`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                        \"Authorization\": `Basic ${base64.encode(`${clientId}:${clientSecret}`)}`,\n                    },\n                    body,\n                });\n                const result = yield response.json();\n                STATE.lastAuthToken = result.access_token;\n                return result;\n            }\n            catch (error) {\n                console.error(\"Error authenticating:\", error);\n                throw error;\n            }\n        });\n    }\n    account() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!STATE.lastAuthToken) {\n                    throw new Error(\"Authentication is required\");\n                }\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/account`, {\n                    headers: authHeaders(),\n                });\n                return yield response.json();\n            }\n            catch (error) {\n                console.error(\"Error fetching account:\", error);\n                throw error;\n            }\n        });\n    }\n    get broadcasts() {\n        return new AuthBroadcastRoutes(__classPrivateFieldGet(this, _fetch));\n    }\n    get channels() {\n        return new AuthChannelRoutes(__classPrivateFieldGet(this, _fetch));\n    }\n}\n_fetch = new WeakMap();\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _fetch;\nimport { API_ROOT } from \"../config\";\nimport { authHeaders, parseFetchedList } from \"../utils\";\nexport class BaseAuthenticatedRoute {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(this, _fetch, fetch);\n    }\n    get resourceBase() {\n        throw new Error(\"NotImplemented\");\n    }\n    list(params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/${this.resourceBase}`, {\n                    method: 'GET',\n                    headers: Object.assign(Object.assign({}, authHeaders()), { 'Content-Type': 'application/json' }),\n                });\n                return parseFetchedList(response);\n            }\n            catch (error) {\n                throw new Error(`Error in list: ${error.message}`);\n            }\n        });\n    }\n    get(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!id) {\n                throw new Error('id is required');\n            }\n            try {\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/${this.resourceBase}/${id}`, {\n                    method: 'GET',\n                    headers: Object.assign(Object.assign({}, authHeaders()), { 'Content-Type': 'application/json' }),\n                });\n                return response.headers.get('content-type') == 'application/json; charset=utf-8' ? response.json() : response;\n            }\n            catch (error) {\n                throw new Error(`Error in get: ${error.message}`);\n            }\n        });\n    }\n    create(params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/${this.resourceBase}`, {\n                    method: 'POST',\n                    headers: Object.assign(Object.assign({}, authHeaders()), { 'Content-Type': 'application/json' }),\n                    body: JSON.stringify(params),\n                });\n                return response.headers.get('content-type') == 'application/json; charset=utf-8' ? response.json() : response;\n            }\n            catch (error) {\n                throw new Error(`Error in create: ${error.message}`);\n            }\n        });\n    }\n    update(id, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!id) {\n                throw new Error('id is required');\n            }\n            try {\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/${this.resourceBase}/${id}`, {\n                    method: 'PUT',\n                    headers: Object.assign(Object.assign({}, authHeaders()), { 'Content-Type': 'application/json' }),\n                    body: JSON.stringify(params),\n                });\n                return response.headers.get('content-type') == 'application/json; charset=utf-8' ? response.json() : response;\n            }\n            catch (error) {\n                throw new Error(`Error in update: ${error.message}`);\n            }\n        });\n    }\n    destroy(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!id) {\n                throw new Error('id is required');\n            }\n            try {\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/${this.resourceBase}/${id}`, {\n                    method: 'DELETE',\n                    headers: Object.assign(Object.assign({}, authHeaders()), { 'Content-Type': 'application/json' }),\n                });\n                return response.headers.get('content-type') == 'application/json; charset=utf-8' ? response.json() : response;\n            }\n            catch (error) {\n                throw new Error(`Error in destroy: ${error.message}`);\n            }\n        });\n    }\n}\n_fetch = new WeakMap();\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _fetch;\n//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nimport qs from 'qs';\nimport { API_ROOT } from \"../config\";\nimport { parseFetchedList } from \"../utils\";\nexport default class BroadcastRoutes {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(this, _fetch, fetch);\n    }\n    list(channelId, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!channelId) {\n                return Promise.reject(\"channelId is required\");\n            }\n            const res = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/channels/${channelId}/broadcasts?${qs.stringify(params)}`);\n            return yield parseFetchedList(res);\n        });\n    }\n    get(broadcastId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!broadcastId) {\n                return Promise.reject(\"broadcastId is required\");\n            }\n            const res = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/broadcasts/${broadcastId}`);\n            return yield res.json();\n        });\n    }\n}\n_fetch = new WeakMap();\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _fetch;\n//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nimport qs from 'qs';\nimport { API_ROOT } from \"../config\";\nimport { parseFetchedList } from \"../utils\";\nexport default class ChannelRoutes {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(this, _fetch, fetch);\n    }\n    list(accountId, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!accountId) {\n                return Promise.reject(\"accountId is required\");\n            }\n            const res = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/accounts/${accountId}/channels?${qs.stringify(params)}`);\n            return yield parseFetchedList(res);\n        });\n    }\n}\n_fetch = new WeakMap();\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _fetch;\nimport BroadcastRoutes from \"./broadcast_routes\";\nimport ChannelRoutes from './channel_routes';\nimport ViewRoutes from './view_routes';\nimport AuthRoutes from './auth_routes';\nexport class api {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(this, _fetch, fetch);\n        this.broadcasts = new BroadcastRoutes(__classPrivateFieldGet(this, _fetch));\n        this.channels = new ChannelRoutes(__classPrivateFieldGet(this, _fetch));\n        this.auth = new AuthRoutes(__classPrivateFieldGet(this, _fetch));\n        this.views = new ViewRoutes(__classPrivateFieldGet(this, _fetch));\n    }\n}\n_fetch = new WeakMap();\nexport default api;\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _fetch;\nimport { API_ROOT } from '../config';\nexport default class ViewRoutes {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(this, _fetch, fetch);\n    }\n    get(broadcastId, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!broadcastId) {\n                return Promise.reject('broadcastId is required');\n            }\n            try {\n                const response = yield __classPrivateFieldGet(this, _fetch).call(this, `${API_ROOT}/broadcasts/${broadcastId}/view`, { params });\n                const view = yield response.json();\n                if (view && view.playlist) {\n                    if (view.status.indexOf('live') < 0 && view.status.indexOf('recorded') < 0) {\n                        // Not yet ready; shouldn't start looking at this playlist.\n                        console.log('Playlist not yet ready; status is [', view.status, '] for ', view.playlist);\n                        view.playlist = '';\n                    }\n                }\n                return view;\n            }\n            catch (error) {\n                return Promise.reject(error);\n            }\n        });\n    }\n}\n_fetch = new WeakMap();\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nexport const API_ROOT = 'https://rest.boxcast.com';\nexport const AUTH_ROOT = 'https://auth.boxcast.com';\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _fetch;\nimport { api } from './api';\nimport { analytics } from './analytics';\nexport class Main {\n    constructor(fetch) {\n        _fetch.set(this, void 0);\n        __classPrivateFieldSet(this, _fetch, fetch);\n        this.api = new api(__classPrivateFieldGet(this, _fetch));\n        this.analytics = new analytics(__classPrivateFieldGet(this, _fetch));\n    }\n}\n_fetch = new WeakMap();\n","import { Main } from './main';\nexport default class BoxCastSDK extends Main {\n    constructor() {\n        super(require('node-fetch'));\n    }\n}\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\n// Global state\nexport var STATE = {\n    lastAuthToken: null\n};\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nexport default class Clock {\n    static now() {\n        return new Date();\n    }\n}\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Clock from './clock';\nexport { Clock };\nimport MonotonicClock from './monotonic_clock';\nexport { MonotonicClock };\nimport { STATE } from \"../state\";\n// /* eslint max-len: 0 */\nexport function getStorage() {\n    try {\n        try {\n            localStorage.setItem('__sentinel__', 'foo');\n            if (localStorage.getItem('__sentinel__') === 'foo') {\n                localStorage.removeItem('__sentinel__');\n                return localStorage;\n            }\n            return sessionStorage;\n        }\n        catch (e) {\n            // Possible DOMException reading localStorage; try sessionStorage\n            return sessionStorage;\n        }\n    }\n    catch (e) {\n        // Possible DOMException reading sessionStorage; use in-memory mock\n        const mockStorage = {\n            getItem: function (key) {\n                return this[key];\n            },\n            setItem: function (key, value) {\n                this[key] = value;\n            }\n        };\n        return mockStorage;\n    }\n}\nexport function uuid() {\n    var r = function (n) {\n        var text = '', possible = '0123456789ABCDEF';\n        for (var i = 0; i < 5; i++) {\n            text += possible.charAt(Math.floor(Math.random() * possible.length));\n        }\n        return text;\n    };\n    return r(8) + '-' + r(4) + '-' + r(4) + '-' + r(4) + '-' + r(12);\n}\nexport function cleanQuotesFromViewerID(viewerId) {\n    if (!viewerId || viewerId.length < 3) {\n        return viewerId || '';\n    }\n    if (viewerId[0] === '\"' && viewerId[viewerId.length - 1] === '\"') {\n        return viewerId.substring(1, viewerId.length - 1);\n    }\n    return viewerId;\n}\nexport function normalizeError(error, source) {\n    // This error object could come from various sources, depending on playback\n    // and circumstance:\n    //   a) string error description\n    //   b) dictionary with `message` and `data` keys\n    //   c) dictionary with `evt` and `data` keys from hls.js, where `data` is an object with `type`, `details`, and a whole bunch of other keys\n    //   d) error object from native HTML5 video element\n    //\n    // Please note, per the HTML5 spec, these are the following error code values:\n    //   MEDIA_ERR_ABORTED (1) The fetching process for the media resource was aborted by the user agent at the user's request.\n    //   MEDIA_ERR_NETWORK (2) A network error of some description caused the user agent to stop fetching the media resource, after the resource was established to be usable.\n    //   MEDIA_ERR_DECODE (3) An error of some description occurred while decoding the media resource, after the resource was established to be usable.\n    //   MEDIA_ERR_SRC_NOT_SUPPORTED (4) The media resource indicated by the src attribute was not suitable.\n    //\n    // Let's try to normalize the reported error a touch\n    error = error || {};\n    const code = (error.code) || (error.data && error.data.code);\n    let message = error.message;\n    if (!message && error.data) {\n        message = error.data.details /* hlsError, cannot be stringified */ || JSON.stringify(error.data);\n    }\n    else {\n        message = error.toString();\n    }\n    if (message === '[object MediaError]') {\n        message = 'MediaError occurred';\n    }\n    let errorObject = {\n        message: message,\n        code: code,\n        data: error.data\n    };\n    if (source) {\n        errorObject.source = source;\n    }\n    return errorObject;\n}\nexport function normalizeAxiosError(error) {\n    // Error could be nil, or it could be a response-like object, or it could\n    // contain a nested response :(\n    if (!error) {\n        return 'Unknown error';\n    }\n    else if (error.response && error.response.data) {\n        return error.response.data;\n    }\n    else if (error.data) {\n        return error.data;\n    }\n    return error;\n}\nexport function parseFetchedList(response) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n        const isJsonResponse = ((_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('content-type')) && ((_b = response.headers) === null || _b === void 0 ? void 0 : _b.get('content-type').indexOf('application/json')) == 0;\n        let pagination = JSON.parse(((_c = response.headers) === null || _c === void 0 ? void 0 : _c.get('x-pagination')) || \"{}\");\n        let obj = {\n            pagination,\n        };\n        obj.data = isJsonResponse ? yield response.json() : response;\n        return obj;\n    });\n}\nexport function authHeaders() {\n    return {\n        Authorization: `Bearer ${STATE.lastAuthToken}`,\n    };\n}\n","//\n// Copyright (c) BoxCast, Inc. and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\n//\nimport Clock from './clock';\nvar supportsPerformanceAPI = null;\nexport default class MonotonicClock {\n    static now() {\n        if (supportsPerformanceAPI === null) {\n            // This code should only run on the first call to this function to evaluate whether or not the performance API is\n            // supported.\n            supportsPerformanceAPI = !!(window.performance && window.performance.now);\n            if (supportsPerformanceAPI) {\n                // Test it out... let's make sure it doesn't explode\n                try {\n                    window.performance.now();\n                }\n                catch (err) {\n                    console.warn('Error calling window.performance.now():', err);\n                    supportsPerformanceAPI = false;\n                }\n            }\n            if (!supportsPerformanceAPI) {\n                console.warn('Browser does not support performance API; MonotonicClock falling back to Clock');\n            }\n        }\n        if (supportsPerformanceAPI) {\n            return window.performance.now();\n        }\n        return Clock.now().getTime();\n    }\n}\n","module.exports = require(\"base-64\");;","module.exports = require(\"node-fetch\");;","module.exports = require(\"platform\");;","module.exports = require(\"qs\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./src/node.ts\");\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;ACjCA;AACA;A;;;;;;;;ACDA;AACA;A;;;;;;;;ACDA;AACA;A;;;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;;;A","sourceRoot":""}